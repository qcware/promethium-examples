# generated by datamodel-codegen:
#   filename:  promethium-openapi.yaml
#   timestamp: 2023-09-26T06:30:40+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import UUID4, BaseModel, Extra, Field, conint


class WorkflowKind(Enum):
    TorsionScan = 'TorsionScan'
    ConformerSearch = 'ConformerSearch'
    SinglePointCalculation = 'SinglePointCalculation'
    GeometryOptimization = 'GeometryOptimization'
    InteractionEnergyCalculation = 'InteractionEnergyCalculation'
    ReactionPathOptimization = 'ReactionPathOptimization'
    TransitionStateOptimization = 'TransitionStateOptimization'
    TransitionStateOptimizationFromEndpoints = (
        'TransitionStateOptimizationFromEndpoints'
    )


class WorkflowStatus(Enum):
    CANCELED = 'CANCELED'
    COMPLETED = 'COMPLETED'
    FAILED = 'FAILED'
    RUNNING = 'RUNNING'
    TERMINATED = 'TERMINATED'
    TIMED_OUT = 'TIMED_OUT'


class WorkflowOrderField(Enum):
    id = 'id'
    name = 'name'
    kind = 'kind'
    created_at = 'created_at'
    last_updated_at = 'last_updated_at'
    started_at = 'started_at'
    stopped_at = 'stopped_at'
    status = 'status'


class OrderDir(Enum):
    asc = 'asc'
    desc = 'desc'


class GpuType(Enum):
    a100 = 'a100'
    v100 = 'v100'


class ResourceRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    gpu_type: GpuType = Field(
        ...,
        description="The class of GPU used to run the workflow; can be one of ['a100', 'v100']",
    )
    gpu_count: Optional[int] = Field(
        1,
        description='The number of GPU units used to run the workflow',
        title='Gpu Count',
    )


class Version(Enum):
    v1 = 'v1'


class Workflow(BaseModel):
    class Config:
        extra = Extra.forbid

    version: Optional[Version] = Field('v1', title='Version')
    id: UUID4 = Field(..., description='The unique id of the workflow', title='Id')
    name: str = Field(
        ..., description='The user-defined name of the workflow', title='Name'
    )
    kind: WorkflowKind = Field(
        ...,
        description="The type of workflow; can be one of ['TorsionScan', 'ConformerSearch', 'SinglePointCalculation', 'GeometryOptimization', 'InteractionEnergyCalculation', 'ReactionPathOptimization', 'TransitionStateOptimization', 'TransitionStateOptimizationFromEndpoints']",
    )
    created_at: datetime = Field(
        ..., description='The creation date of the workflow', title='Created At'
    )
    last_updated_at: datetime = Field(
        ..., description='The last update date of the workflow', title='Last Updated At'
    )
    started_at: Optional[datetime] = Field(
        None, description='The date when the workflow started', title='Started At'
    )
    stopped_at: Optional[datetime] = Field(
        None, description='The date when the workflow stopped', title='Stopped At'
    )
    status: WorkflowStatus = Field(
        ...,
        description="The status of the workflow; can be one of ['CANCELED', 'COMPLETED', 'FAILED', 'RUNNING', 'TERMINATED', 'TIMED_OUT']",
    )
    duration_seconds: float = Field(
        ...,
        description='The running time in seconds of the workflow',
        title='Duration Seconds',
    )
    parameters: Optional[Dict[str, Any]] = Field(None, title='Parameters')
    resources: ResourceRequest


class PageWorkflow(BaseModel):
    items: List[Workflow] = Field(..., title='Items')
    total: conint(ge=0) = Field(..., title='Total')
    page: conint(ge=1) = Field(..., title='Page')
    size: conint(ge=1) = Field(..., title='Size')


class ValidationError(BaseModel):
    loc: List[Union[str, int]] = Field(..., title='Location')
    msg: str = Field(..., title='Message')
    type: str = Field(..., title='Error Type')


class HTTPValidationError(BaseModel):
    detail: Optional[List[ValidationError]] = Field(None, title='Detail')


class ValidFileExtensions(Enum):
    xyz = 'xyz'
    mol = 'mol'
    sdf = 'sdf'
    pdb = 'pdb'
    smi = 'smi'


class MoleculeInput(BaseModel):
    filename: Optional[str] = Field(None, title='Filename')
    base64data: Optional[str] = Field(None, title='Base64Data')
    id: Optional[UUID4] = Field(None, title='Id')
    filetype: Optional[ValidFileExtensions] = None


class ConformerSearchParams(BaseModel):
    class Config:
        extra = Extra.forbid

    charge: Optional[int] = Field(
        None, description='Set the charge of molecule', title='Charge'
    )
    multiplicity: Optional[int] = Field(
        None,
        description='Multiplicity (2S + 1) of the electronic state',
        title='Multiplicity',
    )
    max_filter_jobs: Optional[int] = Field(
        None,
        description='Maximum number of filter nodes for parallelization',
        title='Max Filter Jobs',
    )
    confgen: Optional[bool] = Field(
        None,
        description='Generate initial conformers using RDKits ETKG method',
        title='Confgen',
    )
    confgen_max_n_conformers: Optional[int] = Field(
        None,
        description='Number of initial conformers using RDKits ETKG method',
        title='Confgen Max N Conformers',
    )
    confgen_rmsd_threshold: Optional[float] = Field(
        None,
        description='RMSD threshold for conformer pruning after RDKits ETKG method',
        title='Confgen Rmsd Threshold',
    )


class FilterType(Enum):
    ForceField = 'ForceField'
    ANI = 'ANI'
    DFT = 'DFT'


class ForceFieldType(Enum):
    UFF = 'UFF'
    MMFF = 'MMFF'
    SAGE = 'SAGE'


class ANIFilterMethod(Enum):
    GFN_FF = 'GFN-FF'
    GFN2_xTB = 'GFN2-xTB'
    ANI_2x = 'ANI-2x'


class ANIFilterSolvent(Enum):
    none = 'none'
    acetone = 'acetone'
    acetonitrile = 'acetonitrile'
    benzene = 'benzene'
    ch2cl2 = 'ch2cl2'
    chloroform = 'chloroform'
    cs2 = 'cs2'
    dmf = 'dmf'
    dmso = 'dmso'
    ether = 'ether'
    water = 'water'
    methanol = 'methanol'
    n_hexane = 'n-hexane'
    thf = 'thf'
    toluene = 'toluene'


class ConformerSearchFilterParams(BaseModel):
    class Config:
        extra = Extra.forbid

    forcefield_type: Optional[ForceFieldType] = Field(
        None, description='Force Field used to optimize conformers'
    )
    rmsd_threshold: Optional[float] = Field(
        None,
        description='RMSD threshold for conformer pruning after FF opt',
        title='Rmsd Threshold',
    )
    coulomb_distance_threshold: Optional[float] = Field(
        None,
        description='Threshold of Coulomb matrix norm for conformer pruning after FF opt',
        title='Coulomb Distance Threshold',
    )
    tdf_threshold: Optional[float] = Field(
        None, description='TDF threshold for conformer pruning', title='Tdf Threshold'
    )
    soap_threshold: Optional[float] = Field(
        None,
        description='SOAP distance threshold for conformer pruning',
        title='Soap Threshold',
    )
    method: Optional[ANIFilterMethod] = Field(
        None, description='Supported methods are: GFN-FF, GFN2-xTB and ANI-2x'
    )
    solvent: Optional[ANIFilterSolvent] = Field(
        None, description='Solvent for the GFN methods'
    )
    max_n_conformers: Optional[int] = Field(
        None,
        description='Maximum number of Conformers for the DFT opt',
        title='Max N Conformers',
    )
    energy_threshold: Optional[float] = Field(
        None,
        description='Energy cut-off for pruning in kcal/mol',
        title='Energy Threshold',
    )
    distance_threshold: Optional[float] = Field(
        None,
        description='Distance threshold for pruning (SOAP)',
        title='Distance Threshold',
    )
    do_geometry_optimization: Optional[bool] = Field(
        None,
        description='Turn on geomtry optimzation',
        title='Do Geometry Optimization',
    )
    maxiter: Optional[int] = Field(
        None,
        description='Maximum number of steps in the geometry optimzation',
        title='Maxiter',
    )
    g_thresh: Optional[float] = Field(
        None,
        description='Gradient threshold for geometry optimzation',
        title='G Thresh',
    )


class D3Type(Enum):
    d3 = 'd3'
    d3m = 'd3m'
    bj = 'bj'
    bjm = 'bjm'


class GridOrientationScheme(Enum):
    lab = 'lab'
    global_ = 'global'
    local = 'local'


class GridScheme(Enum):
    SG0 = 'SG0'
    SG1 = 'SG1'
    SG2 = 'SG2'
    SG3 = 'SG3'
    GRID1 = 'GRID1'
    GRID2 = 'GRID2'
    GRID3 = 'GRID3'
    GRID4 = 'GRID4'
    GRID5 = 'GRID5'


class SystemParams(BaseModel):
    class Config:
        extra = Extra.forbid

    basis_is_spherical: Optional[bool] = Field(
        None,
        description='Is the basis set spherical, cartesian, or as-specified in the GBS file',
        title='Basis Is Spherical',
    )
    basisname: Optional[str] = Field(
        None,
        description='Name of the primary Gaussian basis set for this system',
        title='Basisname',
    )
    d3_type: Optional[D3Type] = Field(
        None, description='Type of D3 correction to apply'
    )
    do_atm: Optional[bool] = Field(
        None, description='DFTD3 three-body (ATM) term', title='Do Atm'
    )
    ecp_grid_potential_cutoff: Optional[float] = Field(
        None,
        description='Cutoff for ECP potential to determined ECP grid radial extent',
        title='Ecp Grid Potential Cutoff',
    )
    ecp_grid_radial_npoint: Optional[int] = Field(
        None,
        description='Number of radial nodes in ECP grid Gauss-Legendre quadrature',
        title='Ecp Grid Radial Npoint',
    )
    ecp_grid_spherical_npoint: Optional[int] = Field(
        None,
        description='Number of spherical nodes in ECP grid Lebedev quadrature',
        title='Ecp Grid Spherical Npoint',
    )
    gauss_hermite_pack_max_npoint: Optional[int] = Field(
        None,
        description='Maximum number of Gauss-Hermite quadrature points in Tables',
        title='Gauss Hermite Pack Max Npoint',
    )
    jkfit_basisname: Optional[str] = Field(
        None,
        description='Name of the DF-J and/or DF-K auxiliary basis for this system',
        title='Jkfit Basisname',
    )
    k_grid_R_cutoff: Optional[float] = Field(
        None,
        description='Radial grid cutoff for Becke grid construction (< 0.0 indicates no cutoff) for THC-wK',
        title='K Grid R Cutoff',
    )
    k_grid_orientation_denominator_cutoff: Optional[float] = Field(
        None,
        description='Cutoff for inertial tensor denominators in orientation response equations for THC-wK',
        title='K Grid Orientation Denominator Cutoff',
    )
    k_grid_orientation_e: Optional[List[float]] = Field(
        None,
        description='Gaussian exponents in bohr**(-2) for local Becke grid orientation cutoff for THC-wK',
        title='K Grid Orientation E',
    )
    k_grid_orientation_scheme: Optional[GridOrientationScheme] = Field(
        None, description='Scheme for Becke grid orientation for THC-wK'
    )
    k_grid_orientation_w: Optional[List[float]] = Field(
        None,
        description='Gaussian exponents in bohr**(-2) for local Becke grid orientation cutoff for THC-wK',
        title='K Grid Orientation W',
    )
    k_grid_scheme: Optional[GridScheme] = Field(
        None, description='Named grid scheme for manual grid construction for THC-wK'
    )
    methodname: Optional[str] = Field(
        None, description='Method name, including XC, -D3, etc.', title='Methodname'
    )
    minao_basisname: Optional[str] = Field(
        None,
        description='Name of the MinAO basis set for this system',
        title='Minao Basisname',
    )
    pcm_bondi_radial_scale: Optional[float] = Field(
        None,
        description='PCM scale of Bondi radii used to construct PCM Lebedev cavity',
        title='Pcm Bondi Radial Scale',
    )
    pcm_convergence: Optional[float] = Field(
        None,
        description='Maximum allowed element in the charge update at PCM convergence',
        title='Pcm Convergence',
    )
    pcm_cutoff: Optional[float] = Field(
        None,
        description='Tolerance for neglecting PCM charges with small switch function weights',
        title='Pcm Cutoff',
    )
    pcm_epsilon: Optional[float] = Field(
        None, description='PCM dielectric constant epsilon', title='Pcm Epsilon'
    )
    pcm_k: Optional[float] = Field(
        None,
        description='PCM denominator correction, used in f = (epsilon - 1.0) / (epsilon + k)',
        title='Pcm K',
    )
    pcm_maxiter: Optional[int] = Field(
        None,
        description='Maximum number of PCM iterations before convergence failure',
        title='Pcm Maxiter',
    )
    pcm_print_level: Optional[int] = Field(
        None, description='Level of detail to print', title='Pcm Print Level'
    )
    pcm_spherical_npoint: Optional[int] = Field(
        None,
        description='PCM number of Lebedev points per atom',
        title='Pcm Spherical Npoint',
    )
    threshold_pq: Optional[float] = Field(
        None,
        description='Pair cutoff threshold for (pq| functions',
        title='Threshold Pq',
    )
    vv10_grid_R_cutoff: Optional[float] = Field(
        None,
        description='Radial grid cutoff for Becke grid construction for VV10',
        title='Vv10 Grid R Cutoff',
    )
    vv10_grid_orientation_denominator_cutoff: Optional[float] = Field(
        None,
        description='Cutoff for inertial tensor denominators in orientation response equations for VV10',
        title='Vv10 Grid Orientation Denominator Cutoff',
    )
    vv10_grid_orientation_e: Optional[List[float]] = Field(
        None,
        description='Gaussian exponents in bohr**(-2) for local Becke grid orientation cutoff for VV10',
        title='Vv10 Grid Orientation E',
    )
    vv10_grid_orientation_scheme: Optional[GridOrientationScheme] = Field(
        None, description='Scheme for Becke grid orientation for VV10'
    )
    vv10_grid_orientation_w: Optional[List[float]] = Field(
        None,
        description='Gaussian exponents in bohr**(-2) for local Becke grid orientation cutoff for VV10',
        title='Vv10 Grid Orientation W',
    )
    vv10_grid_scheme: Optional[GridScheme] = Field(
        None, description='Named grid scheme for manual grid construction for VV10'
    )
    xc_functional_name: Optional[str] = Field(
        None,
        description='XC functional name for this system',
        title='Xc Functional Name',
    )
    xc_grid_R_cutoff: Optional[float] = Field(
        None,
        description='Radial grid cutoff for Becke grid construction',
        title='Xc Grid R Cutoff',
    )
    xc_grid_orientation_denominator_cutoff: Optional[float] = Field(
        None,
        description='Cutoff for inertial tensor denominators in orientation response equations for Becke grid',
        title='Xc Grid Orientation Denominator Cutoff',
    )
    xc_grid_orientation_e: Optional[List[float]] = Field(
        None,
        description='Gaussian exponents in bohr**(-2) for local Becke grid orientation cutoff',
        title='Xc Grid Orientation E',
    )
    xc_grid_orientation_scheme: Optional[GridOrientationScheme] = Field(
        None, description='Scheme for Becke grid orientation'
    )
    xc_grid_orientation_w: Optional[List[float]] = Field(
        None,
        description='Gaussian exponents in bohr**(-2) for local Becke grid orientation cutoff',
        title='Xc Grid Orientation W',
    )
    xc_grid_scheme: Optional[GridScheme] = Field(
        None, description='Named grid scheme for manual grid construction'
    )
    yuge_exponent: Optional[float] = Field(
        None,
        description='Massive exponent used in a normalized Gaussian density function to approximate a nuclear density',
        title='Yuge Exponent',
    )


class System(BaseModel):
    params: SystemParams


class Gradient3IndexTensorScheme(Enum):
    delete = 'delete'
    cache = 'cache'
    duplicate = 'duplicate'


class PMEKernelAlgorithm(Enum):
    spherical = 'spherical'
    cartesian_v1 = 'cartesian_v1'
    cartesian_v2 = 'cartesian_v2'


class JkBuilderParams(BaseModel):
    class Config:
        extra = Extra.forbid

    df_j_metric_pseudoinverse_cutoff: Optional[float] = Field(
        None,
        description='Eigenvalue cutoff for DF-J metric pseudoinverse_sqrt',
        title='Df J Metric Pseudoinverse Cutoff',
    )
    gradient_3index_tensor_scheme: Optional[Gradient3IndexTensorScheme] = Field(
        None,
        description='Scheme for major 3-index tensor storage during gradient computation',
    )
    lrc_cutoff: Optional[float] = Field(
        None, description='Eigenvalue cutoff for DF-wK sqrt', title='Lrc Cutoff'
    )
    memory: Optional[float] = Field(
        None,
        description='Scratch memory in bytes to use beyond compressed 3-index tensor',
        title='Memory',
    )
    pme_cartesian_a_star_1: Optional[float] = Field(
        None,
        description='Crossover to asymptotic formula for Gauss-Legendre part of Cartesian Coulomb kernel',
        title='Pme Cartesian A Star 1',
    )
    pme_cartesian_a_star_2: Optional[float] = Field(
        None,
        description='Crossover to asymptotic formula for cerf part of Cartesian Coulomb kernel',
        title='Pme Cartesian A Star 2',
    )
    pme_cartesian_mmultiplier: Optional[int] = Field(
        None,
        description='FFT grid size multiplier in cerf part of Cartesian Coulomb kernel',
        title='Pme Cartesian Mmultiplier',
    )
    pme_cartesian_npoint: Optional[int] = Field(
        None,
        description='Number of Gauss-Legendre quadrature points in Cartesian Coulomb kernel',
        title='Pme Cartesian Npoint',
    )
    pme_cartesian_optimize_fft: Optional[bool] = Field(
        None,
        description='Optimize FFT grid sizes in cartesian Coulomb kernel?',
        title='Pme Cartesian Optimize Fft',
    )
    pme_cutoff: Optional[float] = Field(
        None,
        description='PME cutoff for Gaussian FFT grid representation',
        title='Pme Cutoff',
    )
    pme_grid_power: Optional[float] = Field(
        None, description='PME multigrid power law scaling', title='Pme Grid Power'
    )
    pme_grid_spacing: Optional[float] = Field(
        None, description='PME grid spacing in au', title='Pme Grid Spacing'
    )
    pme_kernel_algorithm: Optional[PMEKernelAlgorithm] = Field(
        None, description='PME kernel algorithm'
    )
    pme_spherical_optimize_fft: Optional[bool] = Field(
        None,
        description='Optimize FFT grid sizes in spherical Coulomb kernel?',
        title='Pme Spherical Optimize Fft',
    )
    pme_sr_cutoff: Optional[float] = Field(
        None, description='PME cutoff for short-range correction', title='Pme Sr Cutoff'
    )
    threshold_k_collocation: Optional[float] = Field(
        None,
        description='Cutoff for exchange collocation in orbital basis',
        title='Threshold K Collocation',
    )


class JkBuilder(BaseModel):
    type: Optional[str] = Field('core_dfjk', title='Type')
    params: Optional[JkBuilderParams] = None


class XcEngine(Enum):
    default = 'default'
    libxc = 'libxc'
    tachyon = 'tachyon'
    xcfun = 'xcfun'


class XcBuilderParams(BaseModel):
    class Config:
        extra = Extra.forbid

    threshold_xc_collocation: Optional[float] = Field(
        None,
        description='Cutoff for density collocation in orbital basis',
        title='Threshold Xc Collocation',
    )
    xc_engine: Optional[XcEngine] = Field(
        None, description='Engine to use for XC evaluation'
    )


class XcBuilder(BaseModel):
    params: Optional[XcBuilderParams] = None


class EstParams(BaseModel):
    class Config:
        extra = Extra.forbid

    threshold_ecp: Optional[float] = Field(
        None, description='Cutoff for ECP orbital collocation', title='Threshold Ecp'
    )


class Est(BaseModel):
    params: Optional[EstParams] = None


class DIISStoragePolicy(Enum):
    gpu = 'gpu'
    cpu = 'cpu'


class OrthogonalizationScheme(Enum):
    canonical = 'canonical'
    cholesky = 'cholesky'
    symmetric = 'symmetric'


class HfBaseParams(BaseModel):
    class Config:
        extra = Extra.forbid

    cpscf_convergence: Optional[float] = Field(
        None,
        description='Maximum allowed element in the residual at CPSCF convergence',
        title='Cpscf Convergence',
    )
    cpscf_maxiter: Optional[int] = Field(
        None,
        description='Maximum number of CPSCF iterations before convergence failure',
        title='Cpscf Maxiter',
    )
    diis_flush_niter: Optional[int] = Field(
        None,
        description='Number of SCF iterations between flushes of DIIS object',
        title='Diis Flush Niter',
    )
    diis_max_nvector: Optional[int] = Field(
        None,
        description='Maximum number of vectors in the DIIS history',
        title='Diis Max Nvector',
    )
    diis_storage_policy: Optional[DIISStoragePolicy] = Field(
        None, description='DIIS storage policy'
    )
    g_convergence: Optional[float] = Field(
        None,
        description='Maximum allowed element in the orbital gradient at SCF convergence',
        title='G Convergence',
    )
    level_shift_alpha: Optional[float] = Field(
        None,
        description='Level shift parameter for the alpha orbitals to stabilize convergence',
        title='Level Shift Alpha',
    )
    level_shift_beta: Optional[float] = Field(
        None,
        description='Level shift parameter for the beta orbitals to stabilize convergence',
        title='Level Shift Beta',
    )
    maxiter: Optional[int] = Field(
        None,
        description='Maximum number of SCF iterations before convergence failure',
        title='Maxiter',
    )
    nalpha: Optional[int] = Field(
        None, description='The number of alpha electrons', title='Nalpha'
    )
    nbeta: Optional[int] = Field(
        None, description='The number of beta electrons', title='Nbeta'
    )
    npair: Optional[int] = Field(
        None, description='Total number of electron pairs', title='Npair'
    )
    orthogonalization_scheme: Optional[OrthogonalizationScheme] = Field(
        None, description='Atomic orbital orthogonalization scheme'
    )
    print_gradient_details: Optional[bool] = Field(
        None,
        description='Print details of SCF gradient?',
        title='Print Gradient Details',
    )
    print_gradient_timings: Optional[bool] = Field(
        None,
        description='Print timings at end of SCF gradient computation?',
        title='Print Gradient Timings',
    )
    print_level: Optional[int] = Field(
        None, description='Level of detail to print', title='Print Level'
    )
    print_quote: Optional[bool] = Field(
        None, description='Print quote at end of SCF iterations?', title='Print Quote'
    )
    print_timings: Optional[bool] = Field(
        None,
        description='Print timings at end of SCF iterations?',
        title='Print Timings',
    )
    threshold_canonical_orthogonalization: Optional[float] = Field(
        None,
        description='Canonical orthogonalization eigenvalue threshold',
        title='Threshold Canonical Orthogonalization',
    )


class FilterHf(BaseModel):
    params: Optional[HfBaseParams] = None


class ConformerSearchFilter(BaseModel):
    filtertype: FilterType
    params: Optional[ConformerSearchFilterParams] = None
    system: Optional[System] = None
    jk_builder: Optional[JkBuilder] = None
    xc_builder: Optional[XcBuilder] = None
    est: Optional[Est] = None
    hf: Optional[FilterHf] = None


class ConformerSearchInitializationInputSpec(BaseModel):
    molecule: MoleculeInput
    params: ConformerSearchParams
    filters: List[ConformerSearchFilter] = Field(..., title='Filters')


class Kind(Enum):
    ConformerSearch = 'ConformerSearch'


class CreateConformerSearchWorkflowRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    version: Optional[Version] = Field('v1', title='Version')
    name: str = Field(
        ..., description='The user-defined name of the workflow', title='Name'
    )
    kind: Optional[Kind] = Field('ConformerSearch', title='Kind')
    parameters: ConformerSearchInitializationInputSpec
    resources: ResourceRequest


class HfParams(BaseModel):
    class Config:
        extra = Extra.forbid

    cpscf_convergence: Optional[float] = Field(
        None,
        description='Maximum allowed element in the residual at CPSCF convergence',
        title='Cpscf Convergence',
    )
    cpscf_maxiter: Optional[int] = Field(
        None,
        description='Maximum number of CPSCF iterations before convergence failure',
        title='Cpscf Maxiter',
    )
    diis_flush_niter: Optional[int] = Field(
        None,
        description='Number of SCF iterations between flushes of DIIS object',
        title='Diis Flush Niter',
    )
    diis_max_nvector: Optional[int] = Field(
        None,
        description='Maximum number of vectors in the DIIS history',
        title='Diis Max Nvector',
    )
    diis_storage_policy: Optional[DIISStoragePolicy] = Field(
        None, description='DIIS storage policy'
    )
    g_convergence: Optional[float] = Field(
        None,
        description='Maximum allowed element in the orbital gradient at SCF convergence',
        title='G Convergence',
    )
    level_shift_alpha: Optional[float] = Field(
        None,
        description='Level shift parameter for the alpha orbitals to stabilize convergence',
        title='Level Shift Alpha',
    )
    level_shift_beta: Optional[float] = Field(
        None,
        description='Level shift parameter for the beta orbitals to stabilize convergence',
        title='Level Shift Beta',
    )
    maxiter: Optional[int] = Field(
        None,
        description='Maximum number of SCF iterations before convergence failure',
        title='Maxiter',
    )
    nalpha: Optional[int] = Field(
        None, description='The number of alpha electrons', title='Nalpha'
    )
    nbeta: Optional[int] = Field(
        None, description='The number of beta electrons', title='Nbeta'
    )
    npair: Optional[int] = Field(
        None, description='Total number of electron pairs', title='Npair'
    )
    orthogonalization_scheme: Optional[OrthogonalizationScheme] = Field(
        None, description='Atomic orbital orthogonalization scheme'
    )
    print_gradient_details: Optional[bool] = Field(
        None,
        description='Print details of SCF gradient?',
        title='Print Gradient Details',
    )
    print_gradient_timings: Optional[bool] = Field(
        None,
        description='Print timings at end of SCF gradient computation?',
        title='Print Gradient Timings',
    )
    print_level: Optional[int] = Field(
        None, description='Level of detail to print', title='Print Level'
    )
    print_quote: Optional[bool] = Field(
        None, description='Print quote at end of SCF iterations?', title='Print Quote'
    )
    print_timings: Optional[bool] = Field(
        None,
        description='Print timings at end of SCF iterations?',
        title='Print Timings',
    )
    threshold_canonical_orthogonalization: Optional[float] = Field(
        None,
        description='Canonical orthogonalization eigenvalue threshold',
        title='Threshold Canonical Orthogonalization',
    )
    charge: Optional[int] = Field(
        None, description='Total molecular charge (Z - 2 * npair)', title='Charge'
    )
    multiplicity: int = Field(
        ...,
        description='Multiplicity (2S + 1) of the electronic state',
        title='Multiplicity',
    )


class HfOutputs(BaseModel):
    dipole_derivative: Optional[bool] = Field(
        False, description='Compute dipole derivative?', title='Dipole Derivative'
    )
    gradient: Optional[bool] = Field(
        False, description='Compute gradient?', title='Gradient'
    )
    polarizability: Optional[bool] = Field(
        False, description='Compute polarizability?', title='Polarizability'
    )


class Hf(BaseModel):
    params: HfParams
    outputs: Optional[HfOutputs] = None


class RcisParams(BaseModel):
    class Config:
        extra = Extra.forbid

    S_inds: Optional[List[int]] = Field(
        None, description='List of spin indices', title='S Inds'
    )
    S_nstates: Optional[List[int]] = Field(
        None,
        description='List of number of states requested in each spin index',
        title='S Nstates',
    )
    gradient_target: Optional[int] = Field(
        None,
        description='What state should be used in gradient calculations',
        title='Gradient Target',
    )
    gradient_target_spin: Optional[int] = Field(
        None,
        description='Spin of the state to be used in gradient calculations',
        title='Gradient Target Spin',
    )
    maxiter: Optional[int] = Field(
        None, description='Maximum number of Davidson iterations', title='Maxiter'
    )
    nguess_per_root: Optional[int] = Field(
        None,
        description='Number of guess vectors to use per desired root',
        title='Nguess Per Root',
    )
    nmax: Optional[int] = Field(
        None, description='Maximum Davidson subspace size', title='Nmax'
    )
    norm_cutoff: Optional[float] = Field(
        None, description='Davidson conditioning cutoff', title='Norm Cutoff'
    )
    print_level: Optional[int] = Field(
        None, description='Level of detail to print', title='Print Level'
    )
    r_convergence: Optional[float] = Field(
        None, description='Davidson convergence criterion', title='R Convergence'
    )


class RcisOutputs(BaseModel):
    gradient: Optional[bool] = Field(
        False, description='Compute gradient?', title='Gradient'
    )


class Rcis(BaseModel):
    params: RcisParams
    outputs: Optional[RcisOutputs] = None


class CoordinateSystemName(Enum):
    redundant = 'redundant'
    cartesian = 'cartesian'
    hybrid = 'hybrid'


class PesParams(BaseModel):
    class Config:
        extra = Extra.forbid

    colinear_threshold: Optional[float] = Field(
        None,
        description='Threshold in determining colinearity of cartesian constraints',
        title='Colinear Threshold',
    )
    constraint_maxiter: Optional[int] = Field(
        None,
        description='Maximum number of iterations to satisfy the constraints',
        title='Constraint Maxiter',
    )
    constraint_tolerance: Optional[float] = Field(
        None,
        description='How tightly do the constraints need to be satisfied',
        title='Constraint Tolerance',
    )
    constraints: Optional[List[Dict[str, Any]]] = Field(
        None,
        description='List of coordinates to constrain during optimization',
        title='Constraints',
    )
    coordinate_system_name: Optional[CoordinateSystemName] = Field(
        None, description='Method for calculating energies and gradients'
    )
    coordinate_transformation_maxiter: Optional[int] = Field(
        None,
        description='Maximum number of iterations in the internal coordinate transformation',
        title='Coordinate Transformation Maxiter',
    )
    coordinate_transformation_thresh: Optional[float] = Field(
        None,
        description='How accurately should we solve the internal coordinate transformation',
        title='Coordinate Transformation Thresh',
    )
    covalent_scale: Optional[float] = Field(
        None,
        description='Scale factor for the covalent radii used to determine bonding pattern',
        title='Covalent Scale',
    )
    directional_derivative_h: Optional[float] = Field(
        None,
        description='Length of finite difference steps for the Hessian formation',
        title='Directional Derivative H',
    )
    directional_derivative_npoint: Optional[int] = Field(
        None,
        description='Number of finite difference points for the Hessian formation',
        title='Directional Derivative Npoint',
    )
    hessian_h: Optional[float] = Field(
        None,
        description='Length of finite difference steps for the Hessian formation',
        title='Hessian H',
    )
    hessian_npoint: Optional[int] = Field(
        None,
        description='Number of finite difference points for the Hessian formation',
        title='Hessian Npoint',
    )
    linear_angle_constraint_thresh: Optional[float] = Field(
        None,
        description='Threshold for allowing an angle constraint to be nonlinear',
        title='Linear Angle Constraint Thresh',
    )
    linear_angle_thresh: Optional[float] = Field(
        None,
        description='Threshold for using the linear angle parameterization',
        title='Linear Angle Thresh',
    )
    metric_inversion_threshold: Optional[float] = Field(
        None,
        description='Threshold for smallest eigenvalue during inversion of redundant coordinate metric',
        title='Metric Inversion Threshold',
    )


class Pes(BaseModel):
    params: PesParams


class DiagonalHessian(Enum):
    unit = 'unit'
    almlof = 'almlof'


class OptimizationScheme(Enum):
    line_search = 'line_search'
    trust_region = 'trust_region'


class LBFGSOptimizationParams(BaseModel):
    class Config:
        extra = Extra.forbid

    decrement_step_max: Optional[int] = Field(
        None,
        description='How many times can the line search fail to find a suitable step before the coordinatae system is rebuilt',
        title='Decrement Step Max',
    )
    diagonal_hessian: Optional[DiagonalHessian] = Field(
        None, description='What should be used for the diagonal hessian?'
    )
    diagonal_hessian_update: Optional[int] = Field(
        None,
        description='How often should the diagonal hessian be updated?',
        title='Diagonal Hessian Update',
    )
    eigenvector_canonical_tolerance: Optional[float] = Field(
        None,
        description='Canonical orthogonalization for hessian eigenvector Davidson',
        title='Eigenvector Canonical Tolerance',
    )
    eigenvector_convergence: Optional[float] = Field(
        None,
        description='How tightly to converge the Hessian eigenvector',
        title='Eigenvector Convergence',
    )
    eigenvector_maxiter: Optional[int] = Field(
        None,
        description='Maximum number of iterations to converge the Hessian eigenvector',
        title='Eigenvector Maxiter',
    )
    eigenvector_maxsubspace: Optional[int] = Field(
        None,
        description='Maximum size of the subspace in the Hessian eigenvector Davidson',
        title='Eigenvector Maxsubspace',
    )
    eigenvector_nguess: Optional[int] = Field(
        None,
        description='Number of guess vectors to use in the Hessian eigenvector Davidson',
        title='Eigenvector Nguess',
    )
    eigenvector_preconditioner_thresh: Optional[float] = Field(
        None,
        description='Hessian eigenvector Davidson preconditioner eigenvalues with magnitude smaller than this value are clamped to this value',
        title='Eigenvector Preconditioner Thresh',
    )
    g_convergence: Optional[float] = Field(
        None,
        description='Convergence threshold on the largest component of the gradient',
        title='G Convergence',
    )
    greedy_optimizer: Optional[bool] = Field(
        None,
        description='Should all steps that lower the energy be accepted?',
        title='Greedy Optimizer',
    )
    internal_fail_max: Optional[int] = Field(
        None,
        description='How many times can the internal coordinate transformation fail before the system is rebuilt',
        title='Internal Fail Max',
    )
    internal_rebuild_max: Optional[int] = Field(
        None,
        description='How many times can the internal coordinate be rebuilt before declaring failure',
        title='Internal Rebuild Max',
    )
    lbfgs_c1_parameter: Optional[float] = Field(
        None,
        description='C1 parameter for evaluating Armijo condition',
        title='Lbfgs C1 Parameter',
    )
    lbfgs_c2_parameter: Optional[float] = Field(
        None,
        description='C2 parameter for evaluating the weak Wolfe condition',
        title='Lbfgs C2 Parameter',
    )
    max_angle_step_size: Optional[float] = Field(
        None,
        description='Largest allowed step size for bond angles',
        title='Max Angle Step Size',
    )
    max_bond_step_size: Optional[float] = Field(
        None,
        description='Largest allowed step size for bond distances',
        title='Max Bond Step Size',
    )
    max_cartesian_step_size: Optional[float] = Field(
        None,
        description='Largest allowed step size for cartesian coordinates',
        title='Max Cartesian Step Size',
    )
    max_center_step_size: Optional[float] = Field(
        None,
        description='Largest allowed step size for center translations',
        title='Max Center Step Size',
    )
    max_linearangle_step_size: Optional[float] = Field(
        None,
        description='Largest allowed step size for bond angles when linear parameterization is used',
        title='Max Linearangle Step Size',
    )
    max_outofplane_step_size: Optional[float] = Field(
        None,
        description='Largest allowed step size for out of plane angles',
        title='Max Outofplane Step Size',
    )
    max_reaction_step_size: Optional[float] = Field(
        None,
        description='Largest allowed step size for reaction coordinates',
        title='Max Reaction Step Size',
    )
    max_rotation_step_size: Optional[float] = Field(
        None,
        description='Largest allowed step size for fragment rotations',
        title='Max Rotation Step Size',
    )
    max_torsion_step_size: Optional[float] = Field(
        None,
        description='Largest allowed step size for bond torsions',
        title='Max Torsion Step Size',
    )
    maxiter: Optional[int] = Field(
        None, description='Maximum number of iterations', title='Maxiter'
    )
    num_hessian_terms: Optional[int] = Field(
        None,
        description='Number of Hessian terms to keep in the L-BFGS',
        title='Num Hessian Terms',
    )
    optimization_scheme: Optional[OptimizationScheme] = Field(
        None, description='Scheme for step control in L-BFGS optimization'
    )
    print_coordinates: Optional[bool] = Field(
        None,
        description='Should the internal coordinates be printed at each step',
        title='Print Coordinates',
    )
    print_level: Optional[int] = Field(
        None, description='Level of detail to print', title='Print Level'
    )
    step_dec_scale: Optional[float] = Field(
        None,
        description='Factor to use when the step scaling parameter must be decreased',
        title='Step Dec Scale',
    )
    step_inc_scale: Optional[float] = Field(
        None,
        description='Factor to use when the step scaling parameter must be increased',
        title='Step Inc Scale',
    )
    step_scale_min: Optional[float] = Field(
        None,
        description='Minimum for the line search scaling factor',
        title='Step Scale Min',
    )
    strict_convergence: Optional[bool] = Field(
        None,
        description='Should all four convergence criteria be satisfied to mark as converged',
        title='Strict Convergence',
    )
    trust_region_delta_e: Optional[float] = Field(
        None,
        description='Defines when the trust radius should be scaled down',
        title='Trust Region Delta E',
    )
    trust_region_delta_i: Optional[float] = Field(
        None,
        description='Defines when the trust radius should be scaled up',
        title='Trust Region Delta I',
    )
    trust_region_delta_o: Optional[float] = Field(
        None,
        description='The trust radius is scaled down when the ratio predicted / expected is outside 1 +/- trust_region_delta_e',
        title='Trust Region Delta O',
    )
    trust_region_epsilon_1: Optional[float] = Field(
        None,
        description='Convergence criterion for the determination of step length',
        title='Trust Region Epsilon 1',
    )
    trust_region_epsilon_2: Optional[float] = Field(
        None,
        description='Convergence criterion for the determination of RFO shift parameter',
        title='Trust Region Epsilon 2',
    )
    trust_region_initial_radius: Optional[float] = Field(
        None,
        description='Initial radius for the trust region',
        title='Trust Region Initial Radius',
    )
    trust_region_lower_bound: Optional[float] = Field(
        None,
        description='Lower bound for allowed trust region steps',
        title='Trust Region Lower Bound',
    )
    trust_region_maximum_radius: Optional[float] = Field(
        None,
        description='Maximum radius for the trust region',
        title='Trust Region Maximum Radius',
    )
    trust_region_maxiter: Optional[float] = Field(
        None,
        description='Maximum number of iterations to determine the step size',
        title='Trust Region Maxiter',
    )
    trust_region_microiteration_maxiter: Optional[float] = Field(
        None,
        description='Maximum number of microiterations to determine the RFO shift parameter',
        title='Trust Region Microiteration Maxiter',
    )
    trust_region_minimum_radius: Optional[float] = Field(
        None,
        description='Minimum radius for the trust region',
        title='Trust Region Minimum Radius',
    )
    trust_region_scale_factor: Optional[float] = Field(
        None,
        description='Defines the factor used to scale the trust radius',
        title='Trust Region Scale Factor',
    )
    trust_region_subproblem_constraint: Optional[float] = Field(
        None,
        description='How tightly should the constraint be solved in the trust region subproblem',
        title='Trust Region Subproblem Constraint',
    )
    trust_region_subproblem_gradient: Optional[float] = Field(
        None,
        description='How tightly should the gradient of the trust region subproblem be converged',
        title='Trust Region Subproblem Gradient',
    )
    trust_region_subproblem_macro_maxiter: Optional[int] = Field(
        None,
        description='How many iterations are allowed in the trust region subproblem to converge the constraint',
        title='Trust Region Subproblem Macro Maxiter',
    )
    trust_region_subproblem_micro_maxiter: Optional[int] = Field(
        None,
        description='How many iterations are allowed in the trust region subproblem to converge the gradient with a fixed constraint',
        title='Trust Region Subproblem Micro Maxiter',
    )
    trust_region_upper_bound: Optional[float] = Field(
        None,
        description='Upper bound for allowed trust region steps',
        title='Trust Region Upper Bound',
    )


class LBFGSOptimizationOutputs(BaseModel):
    dipole_derivatives: Optional[bool] = Field(
        False, description='Compute dipole derivatives?', title='Dipole Derivatives'
    )
    gradient: Optional[bool] = Field(
        False, description='Compute gradient?', title='Gradient'
    )
    hessian: Optional[bool] = Field(
        False, description='Compute hessian?', title='Hessian'
    )
    path: Optional[bool] = Field(True, description='Compute path?', title='Path')
    vibrational_frequencies: Optional[bool] = Field(
        False,
        description='Compute vibrational frequencies?',
        title='Vibrational Frequencies',
    )


class LBFGSOptimization(BaseModel):
    params: LBFGSOptimizationParams
    outputs: Optional[LBFGSOptimizationOutputs] = None


class GeometryOptimizationInputSpec(BaseModel):
    molecule: MoleculeInput
    system: System
    hf: Optional[Hf] = None
    rcis: Optional[Rcis] = None
    pes: Optional[Pes] = None
    est: Optional[Est] = None
    jk_builder: Optional[JkBuilder] = None
    xc_builder: Optional[XcBuilder] = None
    optimization: Optional[LBFGSOptimization] = None


class Kind2(Enum):
    GeometryOptimization = 'GeometryOptimization'


class CreateGeometryOptimizationWorkflowRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    version: Optional[Version] = Field('v1', title='Version')
    name: str = Field(
        ..., description='The user-defined name of the workflow', title='Name'
    )
    kind: Optional[Kind2] = Field('GeometryOptimization', title='Kind')
    parameters: GeometryOptimizationInputSpec
    resources: ResourceRequest


class ChargeAndMultiplicity(BaseModel):
    charge: Optional[int] = Field(None, title='Charge')
    multiplicity: Optional[int] = Field(None, title='Multiplicity')


class MoleculeInputWithChargeAndMultiplicity(BaseModel):
    filename: Optional[str] = Field(None, title='Filename')
    base64data: Optional[str] = Field(None, title='Base64Data')
    id: Optional[UUID4] = Field(None, title='Id')
    filetype: Optional[ValidFileExtensions] = None
    params: Optional[ChargeAndMultiplicity] = None


class InteractionEnergyParams(BaseModel):
    class Config:
        extra = Extra.forbid

    cluster_charge: Optional[int] = Field(None, title='Cluster Charge')
    cluster_multiplicity: Optional[int] = Field(None, title='Cluster Multiplicity')
    print_level: Optional[int] = Field(None, title='Print Level')


class InteractionEnergy(BaseModel):
    params: Optional[InteractionEnergyParams] = None


class InteractionEnergyCalculationInputSpec(BaseModel):
    molecule_a: MoleculeInputWithChargeAndMultiplicity
    molecule_b: MoleculeInputWithChargeAndMultiplicity
    system: System
    interaction_energy: Optional[InteractionEnergy] = None
    hf: Optional[Hf] = None
    rcis: Optional[Rcis] = None
    est: Optional[Est] = None


class Kind3(Enum):
    InteractionEnergyCalculation = 'InteractionEnergyCalculation'


class CreateInteractionEnergyCalculationWorkflowRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    version: Optional[Version] = Field('v1', title='Version')
    name: str = Field(
        ..., description='The user-defined name of the workflow', title='Name'
    )
    kind: Optional[Kind3] = Field('InteractionEnergyCalculation', title='Kind')
    parameters: InteractionEnergyCalculationInputSpec
    resources: ResourceRequest


class GeometryOptimize(BaseModel):
    geometry_optimize: Optional[bool] = Field(None, title='Geometry Optimize')


class MoleculeOutputs(BaseModel):
    vibrational_frequencies: Optional[bool] = Field(
        None, title='Vibrational Frequencies'
    )


class MoleculeInputWithGeometryOptimize(BaseModel):
    filename: Optional[str] = Field(None, title='Filename')
    base64data: Optional[str] = Field(None, title='Base64Data')
    id: Optional[UUID4] = Field(None, title='Id')
    filetype: Optional[ValidFileExtensions] = None
    params: Optional[GeometryOptimize] = None
    outputs: Optional[MoleculeOutputs] = None


class Integrator(Enum):
    euler = 'euler'
    rk45 = 'rk45'


class InterpolatedPathParams(BaseModel):
    class Config:
        extra = Extra.forbid

    alpha: Optional[float] = Field(
        None, description='Interpolation alpha parameter', title='Alpha'
    )
    beta: Optional[float] = Field(
        None, description='Interpolation beta parameter', title='Beta'
    )
    dt: Optional[float] = Field(
        None, description='Initial time step for integrating the path', title='Dt'
    )
    dt_max: Optional[float] = Field(
        None, description='Maximum time step for integrating the path', title='Dt Max'
    )
    dt_min: Optional[float] = Field(
        None, description='Minimum time step for integrating the path', title='Dt Min'
    )
    integrator: Optional[Integrator] = Field(
        None, description='Integrator to use to obtain the interpolated path'
    )
    metric_thresh: Optional[float] = Field(
        None,
        description='Cutoff threshold for eigenvalues of the metric inverse',
        title='Metric Thresh',
    )
    nbeads: Optional[int] = Field(
        None,
        description='Number of beads to use in the final interpolated path',
        title='Nbeads',
    )
    print_level: Optional[int] = Field(
        None, description='Level of detail to print', title='Print Level'
    )
    rk_thresh: Optional[float] = Field(
        None,
        description='Accuracy threshold for the RK45 integrator',
        title='Rk Thresh',
    )
    save_resolution: Optional[float] = Field(
        None,
        description='Save structures when they become this far apart',
        title='Save Resolution',
    )
    sigma: Optional[float] = Field(
        None, description='Interpolation sigma parameter', title='Sigma'
    )


class InterpolatedPath(BaseModel):
    params: Optional[InterpolatedPathParams] = None


class NebPathParams(BaseModel):
    class Config:
        extra = Extra.forbid

    force_constant_lower: Optional[float] = Field(
        None,
        description='Lower bound on the force constant for the NEB springs',
        title='Force Constant Lower',
    )
    force_constant_upper: Optional[float] = Field(
        None,
        description='Upper bound on the force constant for the NEB springs',
        title='Force Constant Upper',
    )


class NebPath(BaseModel):
    params: Optional[NebPathParams] = None


class FIREOptimizerParams(BaseModel):
    class Config:
        extra = Extra.forbid

    alpha_shrink: Optional[float] = Field(
        None,
        description='See: https://doi.org/10.1016/j.commatsci.2020.109584',
        title='Alpha Shrink',
    )
    alpha_start: Optional[float] = Field(
        None,
        description='See: https://doi.org/10.1016/j.commatsci.2020.109584',
        title='Alpha Start',
    )
    delay_step: Optional[int] = Field(
        None,
        description='See: https://doi.org/10.1016/j.commatsci.2020.109584',
        title='Delay Step',
    )
    dt_grow: Optional[float] = Field(
        None,
        description='See: https://doi.org/10.1016/j.commatsci.2020.109584',
        title='Dt Grow',
    )
    dt_shrink: Optional[float] = Field(
        None,
        description='See: https://doi.org/10.1016/j.commatsci.2020.109584',
        title='Dt Shrink',
    )
    dt_start: Optional[float] = Field(
        None,
        description='See: https://doi.org/10.1016/j.commatsci.2020.109584',
        title='Dt Start',
    )
    g_convergence: Optional[float] = Field(
        None,
        description='Convergence threshold on the largest component of the gradient',
        title='G Convergence',
    )
    halfstepback: Optional[bool] = Field(
        None,
        description='See: https://doi.org/10.1016/j.commatsci.2020.109584',
        title='Halfstepback',
    )
    initialdelay: Optional[bool] = Field(
        None,
        description='See: https://doi.org/10.1016/j.commatsci.2020.109584',
        title='Initialdelay',
    )
    maxiter: Optional[int] = Field(
        None, description='Maximum number of iterations', title='Maxiter'
    )
    print_level: Optional[int] = Field(
        None, description='Level of detail to print', title='Print Level'
    )
    tmax: Optional[float] = Field(
        None,
        description='See: https://doi.org/10.1016/j.commatsci.2020.109584',
        title='Tmax',
    )
    tmin: Optional[float] = Field(
        None,
        description='See: https://doi.org/10.1016/j.commatsci.2020.109584',
        title='Tmin',
    )
    vdfmax: Optional[int] = Field(
        None,
        description='See: https://doi.org/10.1016/j.commatsci.2020.109584',
        title='Vdfmax',
    )


class FIREOptimizer(BaseModel):
    params: Optional[FIREOptimizerParams] = None


class ReactionPathOptimizationInputSpec(BaseModel):
    reactant: MoleculeInputWithGeometryOptimize
    product: MoleculeInputWithGeometryOptimize
    system: System
    hf: Optional[Hf] = None
    rcis: Optional[Rcis] = None
    pes: Optional[Pes] = None
    optimization: Optional[LBFGSOptimization] = None
    interpolation: Optional[InterpolatedPath] = None
    neb: Optional[NebPath] = None
    fire: Optional[FIREOptimizer] = None


class Kind4(Enum):
    ReactionPathOptimization = 'ReactionPathOptimization'


class CreateReactionPathOptimizationWorkflowRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    version: Optional[Version] = Field('v1', title='Version')
    name: str = Field(
        ..., description='The user-defined name of the workflow', title='Name'
    )
    kind: Optional[Kind4] = Field('ReactionPathOptimization', title='Kind')
    parameters: ReactionPathOptimizationInputSpec
    resources: ResourceRequest


class SinglePointCalculationInputSpec(BaseModel):
    molecule: MoleculeInput
    system: System
    hf: Hf
    est: Optional[Est] = None
    rcis: Optional[Rcis] = None
    jk_builder: Optional[JkBuilder] = None
    xc_builder: Optional[XcBuilder] = None


class Kind5(Enum):
    SinglePointCalculation = 'SinglePointCalculation'


class CreateSinglePointCalculationWorkflowRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    version: Optional[Version] = Field('v1', title='Version')
    name: str = Field(
        ..., description='The user-defined name of the workflow', title='Name'
    )
    kind: Optional[Kind5] = Field('SinglePointCalculation', title='Kind')
    parameters: SinglePointCalculationInputSpec
    resources: ResourceRequest


class TorsionConstraintParams(BaseModel):
    class Config:
        extra = Extra.forbid

    atomA: Optional[int] = Field(
        None, description='First atom in the torsional angle', title='Atoma'
    )
    atomB: Optional[int] = Field(
        None, description='Second atom in the torsional angle', title='Atomb'
    )
    atomC: Optional[int] = Field(
        None, description='Third atom in the torsional angle', title='Atomc'
    )
    atomD: Optional[int] = Field(
        None, description='Fourth atom in the torsional angle', title='Atomd'
    )


class TorsionConstraint(BaseModel):
    params: TorsionConstraintParams


class RotationalPathParams(BaseModel):
    class Config:
        extra = Extra.forbid

    alpha: Optional[float] = Field(
        None, description='Interpolation alpha parameter', title='Alpha'
    )
    beta: Optional[float] = Field(
        None, description='Interpolation beta parameter', title='Beta'
    )
    coordinate_transformation_maxiter: Optional[int] = Field(
        None,
        description='Maximum number of iterations in the internal coordinate transformation',
        title='Coordinate Transformation Maxiter',
    )
    coordinate_transformation_thresh: Optional[float] = Field(
        None,
        description='How accurately should we solve the internal coordinate transformation',
        title='Coordinate Transformation Thresh',
    )
    covalent_scale: Optional[float] = Field(
        None,
        description='Scale factor for the covalent radii used to determine bonding pattern',
        title='Covalent Scale',
    )
    dt: Optional[float] = Field(
        None, description='Initial time step for integrating the path', title='Dt'
    )
    dt_max: Optional[float] = Field(
        None, description='Maximum time step for integrating the path', title='Dt Max'
    )
    dt_min: Optional[float] = Field(
        None, description='Minimum time step for integrating the path', title='Dt Min'
    )
    integrator: Optional[Integrator] = Field(
        None, description='Integrator to use to obtain the interpolated path'
    )
    linear_angle_thresh: Optional[float] = Field(
        None,
        description='Threshold for using the linear angle parameterization',
        title='Linear Angle Thresh',
    )
    metric_thresh: Optional[float] = Field(
        None,
        description='Cutoff threshold for eigenvalues of the metric inverse',
        title='Metric Thresh',
    )
    nbeads: Optional[conint(ge=1, le=361)] = Field(
        None,
        description='Number of beads to use in the final interpolated path',
        title='Nbeads',
    )
    parameter_exponent: Optional[float] = Field(
        None,
        description='Exponent to apply to the alpha, beta and sigma parameters',
        title='Parameter Exponent',
    )
    print_level: Optional[int] = Field(
        None, description='Level of detail to print', title='Print Level'
    )
    rk_thresh: Optional[float] = Field(
        None,
        description='Accuracy threshold for the RK45 integrator',
        title='Rk Thresh',
    )
    sigma: Optional[float] = Field(
        None, description='Interpolation sigma parameter', title='Sigma'
    )


class RotationalPath(BaseModel):
    params: Optional[RotationalPathParams] = None


class Torsion(BaseModel):
    constraint: TorsionConstraint
    interpolation: Optional[RotationalPath] = None


class TorsionScanInitializationInputSpec(BaseModel):
    molecule: MoleculeInput
    system: System
    torsion: Torsion
    hf: Optional[Hf] = None
    rcis: Optional[Rcis] = None
    pes: Optional[Pes] = None
    est: Optional[Est] = None
    jk_builder: Optional[JkBuilder] = None
    xc_builder: Optional[XcBuilder] = None
    optimization: Optional[LBFGSOptimization] = None


class Kind6(Enum):
    TorsionScan = 'TorsionScan'


class CreateTorsionScanWorkflowRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    version: Optional[Version] = Field('v1', title='Version')
    name: str = Field(
        ..., description='The user-defined name of the workflow', title='Name'
    )
    kind: Optional[Kind6] = Field('TorsionScan', title='Kind')
    parameters: TorsionScanInitializationInputSpec
    resources: ResourceRequest


class Preconditioner(BaseModel):
    system: System
    jk_builder: Optional[JkBuilder] = None
    xc_builder: Optional[XcBuilder] = None
    est: Optional[Est] = None
    hf: Optional[Hf] = None
    rcis: Optional[Rcis] = None
    pes: Optional[Pes] = None


class PRFOOptimizerParams(BaseModel):
    class Config:
        extra = Extra.forbid

    eigenvector_canonical_tolerance: Optional[float] = Field(
        None,
        description='Canonical orthogonalization for hessian eigenvector Davidson',
        title='Eigenvector Canonical Tolerance',
    )
    eigenvector_convergence: Optional[float] = Field(
        None,
        description='How tightly to converge the Hessian eigenvector',
        title='Eigenvector Convergence',
    )
    eigenvector_maxiter: Optional[int] = Field(
        None,
        description='Maximum number of iterations to converge the Hessian eigenvector',
        title='Eigenvector Maxiter',
    )
    eigenvector_maxsubspace: Optional[int] = Field(
        None,
        description='Maximum size of the subspace in the Hessian eigenvector Davidson',
        title='Eigenvector Maxsubspace',
    )
    eigenvector_nguess: Optional[int] = Field(
        None,
        description='Number of guess vectors to use in the Hessian eigenvector Davidson',
        title='Eigenvector Nguess',
    )
    eigenvector_preconditioner_thresh: Optional[float] = Field(
        None,
        description='Hessian eigenvector Davidson preconditioner eigenvalues with magnitude smaller than this value are clamped to this value',
        title='Eigenvector Preconditioner Thresh',
    )
    g_convergence: Optional[float] = Field(
        None,
        description='Convergence threshold on the largest component of the gradient',
        title='G Convergence',
    )
    maxiter: Optional[int] = Field(
        None, description='Maximum number of iterations', title='Maxiter'
    )
    print_level: Optional[int] = Field(
        None, description='Level of detail to print', title='Print Level'
    )
    strict_convergence: Optional[bool] = Field(
        None,
        description='Should all four convergence criteria be satisfied to mark as converged',
        title='Strict Convergence',
    )
    trust_region_delta_e: Optional[float] = Field(
        None,
        description='Defines when the trust radius should be scaled down',
        title='Trust Region Delta E',
    )
    trust_region_delta_i: Optional[float] = Field(
        None,
        description='Defines when the trust radius should be scaled up',
        title='Trust Region Delta I',
    )
    trust_region_epsilon_1: Optional[float] = Field(
        None,
        description='Convergence criterion for the determination of step length',
        title='Trust Region Epsilon 1',
    )
    trust_region_epsilon_2: Optional[float] = Field(
        None,
        description='Convergence criterion for the determination of RFO shift parameter',
        title='Trust Region Epsilon 2',
    )
    trust_region_initial_radius: Optional[float] = Field(
        None,
        description='Initial radius for the trust region',
        title='Trust Region Initial Radius',
    )
    trust_region_lower_bound: Optional[float] = Field(
        None,
        description='Lower bound for allowed trust region steps',
        title='Trust Region Lower Bound',
    )
    trust_region_maximum_radius: Optional[float] = Field(
        None,
        description='Maximum radius for the trust region',
        title='Trust Region Maximum Radius',
    )
    trust_region_maxiter: Optional[float] = Field(
        None,
        description='Maximum number of iterations to determine the step size',
        title='Trust Region Maxiter',
    )
    trust_region_microiteration_maxiter: Optional[float] = Field(
        None,
        description='Maximum number of microiterations to determine the RFO shift parameter',
        title='Trust Region Microiteration Maxiter',
    )
    trust_region_scale_factor: Optional[float] = Field(
        None,
        description='Defines the factor used to scale the trust radius',
        title='Trust Region Scale Factor',
    )
    trust_region_upper_bound: Optional[float] = Field(
        None,
        description='Upper bound for allowed trust region steps',
        title='Trust Region Upper Bound',
    )


class PRFOOptimizerOutputs(BaseModel):
    dipole_derivatives: Optional[bool] = Field(
        False, description='Compute dipole derivatives?', title='Dipole Derivatives'
    )
    gradient: Optional[bool] = Field(
        False, description='Compute gradient?', title='Gradient'
    )
    hessian: Optional[bool] = Field(
        False, description='Compute hessian?', title='Hessian'
    )
    path: Optional[bool] = Field(True, description='Compute path?', title='Path')
    vibrational_frequencies: Optional[bool] = Field(
        False,
        description='Compute vibrational frequencies?',
        title='Vibrational Frequencies',
    )


class PRFOOptimizer(BaseModel):
    params: Optional[PRFOOptimizerParams] = None
    outputs: Optional[PRFOOptimizerOutputs] = None


class TransitionStateOptimizationInputSpec(BaseModel):
    molecule: MoleculeInput
    system: System
    jk_builder: Optional[JkBuilder] = None
    xc_builder: Optional[XcBuilder] = None
    est: Optional[Est] = None
    hf: Optional[Hf] = None
    rcis: Optional[Rcis] = None
    pes: Optional[Pes] = None
    preconditioner: Optional[Preconditioner] = None
    optimization: Optional[PRFOOptimizer] = None


class Kind7(Enum):
    TransitionStateOptimization = 'TransitionStateOptimization'


class CreateTransitionStateOptimizationWorkflowRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    version: Optional[Version] = Field('v1', title='Version')
    name: str = Field(
        ..., description='The user-defined name of the workflow', title='Name'
    )
    kind: Optional[Kind7] = Field('TransitionStateOptimization', title='Kind')
    parameters: TransitionStateOptimizationInputSpec
    resources: ResourceRequest


class TransitionStateOptimizationFromEndpointsInputSpec(BaseModel):
    reactant: MoleculeInputWithGeometryOptimize
    product: MoleculeInputWithGeometryOptimize
    system: System
    jk_builder: Optional[JkBuilder] = None
    xc_builder: Optional[XcBuilder] = None
    est: Optional[Est] = None
    hf: Optional[Hf] = None
    rcis: Optional[Rcis] = None
    pes: Optional[Pes] = None
    preconditioner: Optional[Preconditioner] = None
    optimization: Optional[LBFGSOptimization] = None
    interpolation: Optional[InterpolatedPath] = None
    neb: Optional[NebPath] = None
    fire: Optional[FIREOptimizer] = None
    prfo: Optional[PRFOOptimizer] = None


class Kind8(Enum):
    TransitionStateOptimizationFromEndpoints = (
        'TransitionStateOptimizationFromEndpoints'
    )


class CreateTransitionStateOptimizationFromEndpointsWorkflowRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    version: Optional[Version] = Field('v1', title='Version')
    name: str = Field(
        ..., description='The user-defined name of the workflow', title='Name'
    )
    kind: Optional[Kind8] = Field(
        'TransitionStateOptimizationFromEndpoints', title='Kind'
    )
    parameters: TransitionStateOptimizationFromEndpointsInputSpec
    resources: ResourceRequest


class WorkflowNumericResults(BaseModel):
    class Config:
        extra = Extra.forbid

    id: UUID4 = Field(..., title='Id')
    kind: str = Field(..., title='Kind')
    api_version: str = Field(..., title='Api Version')
    status: WorkflowStatus
    results: Dict[str, Any] = Field(..., title='Results')


class FileMetadata(BaseModel):
    class Config:
        extra = Extra.forbid

    id: UUID4 = Field(..., description='The unique id of the file', title='Id')
    name: str = Field(..., description='The name of the file', title='Name')
    parent_id: Optional[UUID4] = Field(
        None,
        description='The id of the parent directory; optional only for the root',
        title='Parent Id',
    )
    is_directory: bool = Field(
        ...,
        description='True if this is a directory, false otherwise',
        title='Is Directory',
    )
    created_at: datetime = Field(
        ..., description='The creation date of the file', title='Created At'
    )
    size_bytes_uncompressed: Optional[int] = Field(
        0, description='The length of the file', title='Size Bytes Uncompressed'
    )
    sha256_uncompressed: Optional[str] = Field(
        None,
        description='The SHA256 hash of the file contents',
        title='Sha256 Uncompressed',
    )


class UpdateFileRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    parent_id: Optional[UUID4] = Field(
        None,
        description='The id of the parent directory; optional only for the root',
        title='Parent Id',
    )


class PageFileMetadata(BaseModel):
    items: List[FileMetadata] = Field(..., title='Items')
    total: conint(ge=0) = Field(..., title='Total')
    page: conint(ge=1) = Field(..., title='Page')
    size: conint(ge=1) = Field(..., title='Size')


class IsDirectory(Enum):
    boolean_False = False


class CreateSimpleFileRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    name: str = Field(..., description='The name of the file', title='Name')
    parent_id: Optional[UUID4] = Field(
        None,
        description='The id of the parent directory; optional only for the root',
        title='Parent Id',
    )
    is_directory: IsDirectory = Field(..., title='Is Directory')
    base64body: str = Field(
        ..., description='Contents of the file as a base64 string', title='Base64Body'
    )


class IsDirectory1(Enum):
    boolean_True = True


class CreateDirectoryRequest(BaseModel):
    class Config:
        extra = Extra.forbid

    name: str = Field(..., description='The name of the file', title='Name')
    parent_id: Optional[UUID4] = Field(
        None,
        description='The id of the parent directory; optional only for the root',
        title='Parent Id',
    )
    is_directory: IsDirectory1 = Field(..., title='Is Directory')
